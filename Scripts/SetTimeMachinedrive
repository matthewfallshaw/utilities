#!/usr/bin/env ruby

%w[rubygems pathname fileutils active_support].each {|l| require l }
require 'shellwords' rescue nil  # unimportant

LOCKFILE = Pathname.new(File.expand_path("~/tmp/.SetTimeMachinedriverunning"))
TIME_MACHINE_VOLUMES = ["TimeMachine", "Spare"]

def running?
  LOCKFILE.exist? && (LOCKFILE.ctime > Time.now.ago(10.seconds))
end

def notify(message)
  `/usr/local/bin/growlnotify -a Quicksilver -m #{message.shellescape}`
  message
rescue
  # it really doesn't matter if this doesn't work
end

def first_available_time_machine_drive
  TIME_MACHINE_VOLUMES.each do |volume|
    path = Pathname.new("/Volumes/#{volume}/")
    return volume if path.exist?
  end
  return nil
end

def should_run?
  first_available_time_machine_drive &&
    ( latest_backup_drive != first_available_time_machine_drive )
end

def latest_backup_drive
  File.basename(`tmutil latestbackup`.sub(%r{/Backups.backupdb.*},'').chomp)
end

def change_drive
  notify "#$0 is now trying to update your Time Machine drive to #{first_available_time_machine_drive}."
  `sudo tmutil setdestination /Volumes/#{first_available_time_machine_drive}`
end

def run
  `tmutil startbackup`
end

begin
  exit 0 if running?
  FileUtils.touch(LOCKFILE)

  change_drive
  if should_run?
    run
  else
    notify "#$0 called, but decided not to trigger a backup."
  end
ensure
  LOCKFILE.unlink if LOCKFILE.exist?
end
